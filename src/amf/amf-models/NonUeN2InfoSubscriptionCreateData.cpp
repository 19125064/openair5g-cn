/**
* AMF Communicaiton Service
* AMF Communication Service
*
* OpenAPI spec version: 1.R15.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "NonUeN2InfoSubscriptionCreateData.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

NonUeN2InfoSubscriptionCreateData::NonUeN2InfoSubscriptionCreateData()
{
    m_GlobalRanNodeIdIsSet = false;
    m_AnTypeIsSet = false;
    m_N2NotifyCallbackUri = "";
    m_LmfId = "";
    m_LmfIdIsSet = false;
    m_SupportedFeatures = "";
    m_SupportedFeaturesIsSet = false;
    
}

NonUeN2InfoSubscriptionCreateData::~NonUeN2InfoSubscriptionCreateData()
{
}

void NonUeN2InfoSubscriptionCreateData::validate()
{
    // TODO: implement validation
}

nlohmann::json NonUeN2InfoSubscriptionCreateData::toJson() const
{
    nlohmann::json val = nlohmann::json::object();

    {
        nlohmann::json jsonArray;
        for( auto& item : m_GlobalRanNodeId )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            val["globalRanNodeId"] = jsonArray;
        } 
    }
    {
        nlohmann::json jsonArray;
        for( auto& item : m_AnType )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            val["anType"] = jsonArray;
        } 
    }
    val["n2InformationClass"] = ModelBase::toJson(m_N2InformationClass);
    val["n2NotifyCallbackUri"] = ModelBase::toJson(m_N2NotifyCallbackUri);
    if(m_LmfIdIsSet)
    {
        val["lmfId"] = ModelBase::toJson(m_LmfId);
    }
    if(m_SupportedFeaturesIsSet)
    {
        val["supportedFeatures"] = ModelBase::toJson(m_SupportedFeatures);
    }
    

    return val;
}

void NonUeN2InfoSubscriptionCreateData::fromJson(const nlohmann::json& val)
{
    {
        m_GlobalRanNodeId.clear();
        if(val.find("globalRanNodeId") != val.end())
        {
            for( auto& item : val["globalRanNodeId"] )
            {
                
                if(item.is_null())
                {
                    m_GlobalRanNodeId.push_back( GlobalRanNodeId() );
                }
                else
                {
                    GlobalRanNodeId newItem;
                    newItem.fromJson(item);
                    m_GlobalRanNodeId.push_back( newItem );
                }
                
            }
        }
    }
    {
        m_AnType.clear();
        if(val.find("anType") != val.end())
        {
            for( auto& item : val["anType"] )
            {
                
                if(item.is_null())
                {
                    m_AnType.push_back( AccessType() );
                }
                else
                {
                    AccessType newItem;
                    newItem.fromJson(item);
                    m_AnType.push_back( newItem );
                }
                
            }
        }
    }
    setN2NotifyCallbackUri(val.at("n2NotifyCallbackUri"));
    if(val.find("lmfId") != val.end())
    {
        setLmfId(val.at("lmfId"));
    }
    if(val.find("supportedFeatures") != val.end())
    {
        setSupportedFeatures(val.at("supportedFeatures"));
    }
    
}


std::vector<GlobalRanNodeId>& NonUeN2InfoSubscriptionCreateData::getGlobalRanNodeId()
{
    return m_GlobalRanNodeId;
}
bool NonUeN2InfoSubscriptionCreateData::globalRanNodeIdIsSet() const
{
    return m_GlobalRanNodeIdIsSet;
}
void NonUeN2InfoSubscriptionCreateData::unsetGlobalRanNodeId()
{
    m_GlobalRanNodeIdIsSet = false;
}
std::vector<AccessType>& NonUeN2InfoSubscriptionCreateData::getAnType()
{
    return m_AnType;
}
bool NonUeN2InfoSubscriptionCreateData::anTypeIsSet() const
{
    return m_AnTypeIsSet;
}
void NonUeN2InfoSubscriptionCreateData::unsetAnType()
{
    m_AnTypeIsSet = false;
}
N2InformationClass NonUeN2InfoSubscriptionCreateData::getN2InformationClass() const
{
    return m_N2InformationClass;
}
void NonUeN2InfoSubscriptionCreateData::setN2InformationClass(N2InformationClass const& value)
{
    m_N2InformationClass = value;
    
}
std::string NonUeN2InfoSubscriptionCreateData::getN2NotifyCallbackUri() const
{
    return m_N2NotifyCallbackUri;
}
void NonUeN2InfoSubscriptionCreateData::setN2NotifyCallbackUri(std::string const& value)
{
    m_N2NotifyCallbackUri = value;
    
}
std::string NonUeN2InfoSubscriptionCreateData::getLmfId() const
{
    return m_LmfId;
}
void NonUeN2InfoSubscriptionCreateData::setLmfId(std::string const& value)
{
    m_LmfId = value;
    m_LmfIdIsSet = true;
}
bool NonUeN2InfoSubscriptionCreateData::lmfIdIsSet() const
{
    return m_LmfIdIsSet;
}
void NonUeN2InfoSubscriptionCreateData::unsetLmfId()
{
    m_LmfIdIsSet = false;
}
std::string NonUeN2InfoSubscriptionCreateData::getSupportedFeatures() const
{
    return m_SupportedFeatures;
}
void NonUeN2InfoSubscriptionCreateData::setSupportedFeatures(std::string const& value)
{
    m_SupportedFeatures = value;
    m_SupportedFeaturesIsSet = true;
}
bool NonUeN2InfoSubscriptionCreateData::supportedFeaturesIsSet() const
{
    return m_SupportedFeaturesIsSet;
}
void NonUeN2InfoSubscriptionCreateData::unsetSupportedFeatures()
{
    m_SupportedFeaturesIsSet = false;
}

}
}
}
}

