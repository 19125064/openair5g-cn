/**
* AMF Communicaiton Service
* AMF Communication Service
*
* OpenAPI spec version: 1.R15.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "pistache/endpoint.h"
#include "pistache/http.h"
#include "pistache/router.h"
#ifdef __linux__
#include <vector>
#include <signal.h>
#include <unistd.h>
#endif

#include "AMFStatusChangeSubscribeApiImpl.h"
#include "AMFStatusChangeSubscribeModifyApiImpl.h"
#include "AMFStatusChangeUnSubscribeApiImpl.h"
#include "CreateUEContxtApiImpl.h"
#include "EBIAssignmentApiImpl.h"
#include "N1N2MessageSubscribeApiImpl.h"
#include "N1N2MessageTransferApiImpl.h"
#include "N1N2MessageUnSubscribeApiImpl.h"
#include "NonUEN2InfoSubscribeApiImpl.h"
#include "NonUEN2InfoUnSubscribeApiImpl.h"
#include "NonUEN2MessageTransferApiImpl.h"
#include "ReleaseUEContxtApiImpl.h"
#include "UEContextTransferApiImpl.h"

#define PISTACHE_SERVER_THREADS 2

static Pistache::Http::Endpoint *httpEndpoint;
#ifdef __linux__
static void sigHandler(int sig){
    switch(sig){
        case SIGINT:
        case SIGQUIT:
        case SIGTERM:
        case SIGHUP:
        default:
            httpEndpoint->shutdown();
            break;
    }
    exit(0);
}

static void setUpUnixSignals(std::vector<int> quitSignals) {
    sigset_t blocking_mask;
    sigemptyset(&blocking_mask);
    for (auto sig : quitSignals)
        sigaddset(&blocking_mask, sig);

    struct sigaction sa;
    sa.sa_handler = sigHandler;
    sa.sa_mask    = blocking_mask;
    sa.sa_flags   = 0;

    for (auto sig : quitSignals)
        sigaction(sig, &sa, nullptr);
}
#endif

using namespace org::openapitools::server::api;

int main() {
#ifdef __linux__
    std::vector<int> sigs{SIGQUIT, SIGINT, SIGTERM, SIGHUP};
    setUpUnixSignals(sigs);
#endif
    Pistache::Address addr(Pistache::Ipv4::any(), Pistache::Port(5000));

    httpEndpoint = new Pistache::Http::Endpoint((addr));
    auto router = std::make_shared<Pistache::Rest::Router>();

    auto opts = Pistache::Http::Endpoint::options()
        .threads(PISTACHE_SERVER_THREADS);
    httpEndpoint->init(opts);

    
    AMFStatusChangeSubscribeApiImpl AMFStatusChangeSubscribeApiserver(router);
    AMFStatusChangeSubscribeApiserver.init();
    AMFStatusChangeSubscribeModifyApiImpl AMFStatusChangeSubscribeModifyApiserver(router);
    AMFStatusChangeSubscribeModifyApiserver.init();
    AMFStatusChangeUnSubscribeApiImpl AMFStatusChangeUnSubscribeApiserver(router);
    AMFStatusChangeUnSubscribeApiserver.init();
    CreateUEContxtApiImpl CreateUEContxtApiserver(router);
    CreateUEContxtApiserver.init();
    EBIAssignmentApiImpl EBIAssignmentApiserver(router);
    EBIAssignmentApiserver.init();
    N1N2MessageSubscribeApiImpl N1N2MessageSubscribeApiserver(router);
    N1N2MessageSubscribeApiserver.init();
    N1N2MessageTransferApiImpl N1N2MessageTransferApiserver(router);
    N1N2MessageTransferApiserver.init();
    N1N2MessageUnSubscribeApiImpl N1N2MessageUnSubscribeApiserver(router);
    N1N2MessageUnSubscribeApiserver.init();
    NonUEN2InfoSubscribeApiImpl NonUEN2InfoSubscribeApiserver(router);
    NonUEN2InfoSubscribeApiserver.init();
    NonUEN2InfoUnSubscribeApiImpl NonUEN2InfoUnSubscribeApiserver(router);
    NonUEN2InfoUnSubscribeApiserver.init();
    NonUEN2MessageTransferApiImpl NonUEN2MessageTransferApiserver(router);
    NonUEN2MessageTransferApiserver.init();
    ReleaseUEContxtApiImpl ReleaseUEContxtApiserver(router);
    ReleaseUEContxtApiserver.init();
    UEContextTransferApiImpl UEContextTransferApiserver(router);
    UEContextTransferApiserver.init();

    httpEndpoint->setHandler(router->handler());
    httpEndpoint->serve();

    httpEndpoint->shutdown();

}

